"""
Tests for backend/db/ modules.

All Supabase I/O is mocked so no real network connection is needed.
The tests exercise:
  - Pydantic model validation and defaults (models.py)
  - Supabase client singleton & error handling (supabase_client.py)
  - Customer segmentation logic and repo functions (customer_repo.py)
  - Analytics aggregation logic and log_interaction (analytics_repo.py)
"""
from __future__ import annotations

import importlib
import os
import sys
from datetime import datetime, timedelta, timezone
from types import ModuleType
from typing import Any, Dict, List
from unittest.mock import MagicMock, patch

import pytest

# ---------------------------------------------------------------------------
# conftest already adds backend/ to sys.path, so direct imports work.
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# helpers
# ---------------------------------------------------------------------------

def _make_supabase_mock(rows: List[Dict] = None) -> MagicMock:
    """Return a mock Supabase client whose table(...).select().execute() chain
    returns the given rows."""
    mock_result = MagicMock()
    mock_result.data = rows or []

    mock_query = MagicMock()
    mock_query.select.return_value = mock_query
    mock_query.eq.return_value = mock_query
    mock_query.limit.return_value = mock_query
    mock_query.update.return_value = mock_query
    mock_query.insert.return_value = mock_query
    mock_query.not_ = mock_query
    mock_query.is_.return_value = mock_query
    mock_query.gte.return_value = mock_query
    mock_query.execute.return_value = mock_result

    mock_client = MagicMock()
    mock_client.table.return_value = mock_query
    return mock_client, mock_query, mock_result


# ===========================================================================
# models.py
# ===========================================================================

class TestModels:

    def test_customer_profile_defaults(self):
        from db.models import CustomerProfile, CustomerSegment
        p = CustomerProfile(user_id="u1", name="Riya")
        assert p.user_id == "u1"
        assert p.total_orders == 0
        assert p.complaint_count == 0
        assert p.customer_segment == CustomerSegment.new.value
        assert p.satisfaction_score is None

    def test_customer_profile_enum_validation(self):
        from db.models import CustomerProfile, CustomerSegment
        p = CustomerProfile(user_id="u2", name="Arjun", customer_segment="bulk")
        assert p.customer_segment == "bulk"

    def test_chat_session_defaults(self):
        from db.models import ChatSession, ResolutionStatus
        s = ChatSession(user_id="u1")
        assert s.user_id == "u1"
        assert s.ended_at is None
        assert s.resolution_status == ResolutionStatus.pending.value

    def test_chat_message_required_fields(self):
        from db.models import ChatMessage, MessageRole
        m = ChatMessage(
            session_id="s1",
            user_id="u1",
            role=MessageRole.user,
            content="Hello",
        )
        assert m.role == "user"
        assert m.hallucination_flagged is False
        assert m.tools_called == []

    def test_complaint_log_resolution_default(self):
        from db.models import ComplaintLog, ResolutionType
        c = ComplaintLog(
            session_id="s1",
            user_id="u1",
            complaint_type="damaged",
        )
        assert c.resolution_type == ResolutionType.none.value
        assert c.resolved_at is None

    def test_offer_given_fields(self):
        from db.models import OfferGiven
        o = OfferGiven(
            user_id="u1",
            session_id="s1",
            offer_type="wallet_credit",
            offer_value=150.0,
            offer_description="₹150 wallet credit",
        )
        assert o.accepted is False
        assert o.offer_value == 150.0

    def test_dispatch_checklist_defaults(self):
        from db.models import DispatchChecklist
        d = DispatchChecklist(session_id="s1", user_id="u1")
        assert d.issues_reported == []
        assert d.checklist_items == []

    def test_complaint_type_invalid(self):
        from db.models import ComplaintLog
        with pytest.raises(Exception):
            ComplaintLog(
                session_id="s1",
                user_id="u1",
                complaint_type="nonexistent_type",
            )

    def test_uuid_autogenerated(self):
        from db.models import ChatSession
        s1 = ChatSession(user_id="u1")
        s2 = ChatSession(user_id="u1")
        assert s1.session_id != s2.session_id


# ===========================================================================
# supabase_client.py
# ===========================================================================

class TestSupabaseClient:

    def setup_method(self):
        # Always reset singleton before each test
        import db.supabase_client as sc
        sc.reset_client()

    def test_missing_url_raises(self):
        with patch.dict(os.environ, {}, clear=True):
            # Ensure both vars are absent
            os.environ.pop("SUPABASE_URL", None)
            os.environ.pop("SUPABASE_ANON_KEY", None)
            from db.supabase_client import get_client, reset_client
            reset_client()
            with pytest.raises(RuntimeError, match="SUPABASE_URL"):
                get_client()

    def test_missing_key_raises(self):
        with patch.dict(os.environ, {"SUPABASE_URL": "https://example.supabase.co"}, clear=False):
            os.environ.pop("SUPABASE_ANON_KEY", None)
            from db.supabase_client import get_client, reset_client
            reset_client()
            with pytest.raises(RuntimeError, match="SUPABASE_ANON_KEY"):
                get_client()

    def _patch_supabase(self, mock_client):
        """Inject a fake `supabase` module so the lazy import inside get_client() works."""
        fake_supabase = MagicMock()
        fake_supabase.create_client.return_value = mock_client
        return patch.dict(sys.modules, {"supabase": fake_supabase})

    def test_singleton_returned(self):
        mock_client = MagicMock()
        with patch.dict(os.environ, {
            "SUPABASE_URL": "https://x.supabase.co",
            "SUPABASE_ANON_KEY": "testkey",
        }):
            with self._patch_supabase(mock_client):
                from db.supabase_client import get_client, reset_client
                reset_client()
                c1 = get_client()
                c2 = get_client()
                assert c1 is c2

    def test_reset_clears_singleton(self):
        mock_client = MagicMock()
        with patch.dict(os.environ, {
            "SUPABASE_URL": "https://x.supabase.co",
            "SUPABASE_ANON_KEY": "testkey",
        }):
            with self._patch_supabase(mock_client):
                from db.supabase_client import get_client, reset_client
                reset_client()
                c1 = get_client()
                reset_client()
                c2 = get_client()
                assert c1 is not None
                assert c2 is not None


# ===========================================================================
# customer_repo.py — segmentation logic (pure function, no DB needed)
# ===========================================================================

class TestCustomerSegmentLogic:
    """Test _compute_segment directly without any DB calls."""

    def _profile(self, **kwargs):
        from db.models import CustomerProfile
        defaults = dict(user_id="u1", name="Test")
        defaults.update(kwargs)
        return CustomerProfile(**defaults)

    def test_new_segment(self):
        from db.customer_repo import _compute_segment
        from db.models import CustomerSegment
        p = self._profile(total_orders=1, complaint_count=0)
        assert _compute_segment(p) == CustomerSegment.new

    def test_frequent_complainer_beats_new(self):
        from db.customer_repo import _compute_segment
        from db.models import CustomerSegment
        # Even with only 1 order, high complaints → frequent_complainer
        p = self._profile(total_orders=1, complaint_count=4)
        assert _compute_segment(p) == CustomerSegment.frequent_complainer

    def test_churning_segment(self):
        from db.customer_repo import _compute_segment
        from db.models import CustomerSegment
        old_date = datetime.now(timezone.utc) - timedelta(days=45)
        p = self._profile(total_orders=5, complaint_count=1, last_complaint_date=old_date)
        assert _compute_segment(p) == CustomerSegment.churning

    def test_bulk_segment(self):
        from db.customer_repo import _compute_segment
        from db.models import CustomerSegment
        recent = datetime.now(timezone.utc) - timedelta(days=5)
        p = self._profile(
            total_orders=10,
            avg_spend_inr=1500.0,
            complaint_count=0,
            last_complaint_date=recent,
        )
        assert _compute_segment(p) == CustomerSegment.bulk

    def test_regular_segment(self):
        from db.customer_repo import _compute_segment
        from db.models import CustomerSegment
        recent = datetime.now(timezone.utc) - timedelta(days=2)
        p = self._profile(
            total_orders=4,
            avg_spend_inr=300.0,
            complaint_count=1,
            last_complaint_date=recent,
        )
        assert _compute_segment(p) == CustomerSegment.regular

    def test_bulk_requires_both_conditions(self):
        """High spend alone is not enough — must also have >5 orders."""
        from db.customer_repo import _compute_segment
        from db.models import CustomerSegment
        recent = datetime.now(timezone.utc) - timedelta(days=2)
        p = self._profile(
            total_orders=3,        # below threshold
            avg_spend_inr=2000.0,  # above threshold
            complaint_count=0,
            last_complaint_date=recent,
        )
        # Falls through to regular because total_orders < 3 → new segment
        result = _compute_segment(p)
        assert result in (CustomerSegment.new, CustomerSegment.regular)


# ===========================================================================
# customer_repo.py — DB functions with mocked Supabase
# ===========================================================================

class TestCustomerRepo:

    def _sample_row(self, **overrides) -> dict:
        base = {
            "user_id": "u1",
            "name": "Priya",
            "phone": "9876543210",
            "total_orders": 5,
            "avg_spend_inr": 800.0,
            "complaint_count": 1,
            "last_complaint_date": None,
            "satisfaction_score": 4.2,
            "customer_segment": "regular",
            "created_at": datetime.utcnow().isoformat(),
            "updated_at": datetime.utcnow().isoformat(),
        }
        base.update(overrides)
        return base

    def test_get_customer_profile_found(self):
        row = self._sample_row()
        mock_client, mock_query, mock_result = _make_supabase_mock([row])
        mock_result.data = [row]

        with patch("db.customer_repo.get_client", return_value=mock_client):
            from db.customer_repo import get_customer_profile
            profile = get_customer_profile("u1")

        assert profile is not None
        assert profile.user_id == "u1"
        assert profile.name == "Priya"

    def test_get_customer_profile_not_found(self):
        mock_client, mock_query, mock_result = _make_supabase_mock([])
        mock_result.data = []

        with patch("db.customer_repo.get_client", return_value=mock_client):
            from db.customer_repo import get_customer_profile
            profile = get_customer_profile("ghost")

        assert profile is None

    def test_create_customer_profile_new(self):
        """When no existing profile, insert should be called."""
        new_row = self._sample_row(user_id="u_new", name="Karan", total_orders=0)
        mock_client, mock_query, mock_result = _make_supabase_mock([])
        # First call (get_customer_profile check) returns no rows
        # Second call (insert) returns the new row
        mock_result.data = []
        insert_result = MagicMock()
        insert_result.data = [new_row]
        mock_query.execute.side_effect = [mock_result, insert_result]

        with patch("db.customer_repo.get_client", return_value=mock_client):
            from db import customer_repo
            # Reload to avoid stale import cache
            profile = customer_repo.create_customer_profile("u_new", "Karan")

        assert profile.user_id == "u_new"

    def test_create_customer_profile_duplicate_raises(self):
        row = self._sample_row()
        mock_client, mock_query, mock_result = _make_supabase_mock([row])
        mock_result.data = [row]

        with patch("db.customer_repo.get_client", return_value=mock_client):
            from db.customer_repo import create_customer_profile
            with pytest.raises(ValueError, match="already exists"):
                create_customer_profile("u1", "Priya")

    def test_get_customer_segment_unknown_for_missing(self):
        mock_client, mock_query, mock_result = _make_supabase_mock([])
        mock_result.data = []

        with patch("db.customer_repo.get_client", return_value=mock_client):
            from db.customer_repo import get_customer_segment
            result = get_customer_segment("ghost_user")

        assert result == "unknown"

    def test_get_customer_segment_returns_string(self):
        row = self._sample_row(total_orders=10, avg_spend_inr=1500.0, complaint_count=0)
        mock_client, mock_query, mock_result = _make_supabase_mock([row])
        mock_result.data = [row]

        with patch("db.customer_repo.get_client", return_value=mock_client):
            from db.customer_repo import get_customer_segment
            result = get_customer_segment("u1")

        assert isinstance(result, str)
        assert result in ("new", "regular", "bulk", "churning", "frequent_complainer")

    def test_update_stats_raises_on_missing_profile(self):
        mock_client, mock_query, mock_result = _make_supabase_mock([])
        mock_result.data = []

        with patch("db.customer_repo.get_client", return_value=mock_client):
            from db.customer_repo import update_customer_stats
            with pytest.raises(ValueError):
                update_customer_stats("ghost", new_order=True)

    def test_update_stats_increments_order(self):
        row = self._sample_row(total_orders=3)
        mock_client, mock_query, mock_result = _make_supabase_mock([row])
        mock_result.data = [row]

        with patch("db.customer_repo.get_client", return_value=mock_client):
            from db.customer_repo import update_customer_stats
            # Should not raise
            update_customer_stats("u1", new_order=True)

        # Verify update() was called on the table
        mock_client.table.assert_called()


# ===========================================================================
# analytics_repo.py
# ===========================================================================

class TestAnalyticsRepo:

    def test_log_interaction_inserts_two_rows(self):
        mock_client, mock_query, mock_result = _make_supabase_mock([])

        with patch("db.analytics_repo.get_client", return_value=mock_client):
            from db.analytics_repo import log_interaction
            log_interaction(
                session_id="s1",
                user_id="u1",
                message="Mera order kahan hai?",
                response="Aapka order on the way hai.",
                emotion="neutral",
                language="hi",
                intent="order_status",
                agent="order_agent",
                tools=["order_lookup_tool"],
                status="resolved",
                latency=312,
                tokens=128,
                hallucination_flagged=False,
            )

        # insert should have been called with a list of 2 rows
        insert_calls = mock_query.insert.call_args_list
        assert len(insert_calls) >= 1
        inserted_rows = insert_calls[0][0][0]
        assert len(inserted_rows) == 2
        assert inserted_rows[0]["role"] == "user"
        assert inserted_rows[1]["role"] == "bot"

    def test_log_interaction_swallows_exceptions(self):
        """log_interaction must not propagate DB errors."""
        with patch("db.analytics_repo.get_client", side_effect=RuntimeError("DB down")):
            from db.analytics_repo import log_interaction
            # Should not raise
            log_interaction("s1", "u1", "hi", "hello")

    def test_get_complaint_analytics_empty(self):
        mock_client, mock_query, mock_result = _make_supabase_mock([])

        with patch("db.analytics_repo.get_client", return_value=mock_client):
            from db.analytics_repo import get_complaint_analytics
            result = get_complaint_analytics()

        assert result["total_complaints"] == 0
        assert result["resolution_rate"] == 0.0
        assert result["by_type"] == {}

    def test_get_complaint_analytics_counts(self):
        now = datetime.utcnow()
        rows = [
            {
                "complaint_type": "damaged",
                "product_name": "Tomatoes",
                "resolution_type": "refund",
                "created_at": (now - timedelta(hours=2)).isoformat(),
                "resolved_at": now.isoformat(),
            },
            {
                "complaint_type": "damaged",
                "product_name": "Onions",
                "resolution_type": "none",
                "created_at": now.isoformat(),
                "resolved_at": None,
            },
            {
                "complaint_type": "missing",
                "product_name": "Tomatoes",
                "resolution_type": "replacement",
                "created_at": (now - timedelta(hours=1)).isoformat(),
                "resolved_at": now.isoformat(),
            },
        ]
        mock_client, mock_query, mock_result = _make_supabase_mock(rows)

        with patch("db.analytics_repo.get_client", return_value=mock_client):
            from db.analytics_repo import get_complaint_analytics
            result = get_complaint_analytics()

        assert result["total_complaints"] == 3
        assert result["by_type"]["damaged"] == 2
        assert result["by_type"]["missing"] == 1
        assert result["by_product"]["Tomatoes"] == 2
        assert result["resolution_rate"] == pytest.approx(2 / 3, rel=1e-3)
        assert result["avg_resolution_time"] > 0

    def test_get_customer_satisfaction_score_no_data(self):
        mock_client, mock_query, mock_result = _make_supabase_mock([])

        with patch("db.analytics_repo.get_client", return_value=mock_client):
            from db.analytics_repo import get_customer_satisfaction_score
            score = get_customer_satisfaction_score()

        assert score == 0.0

    def test_get_customer_satisfaction_score_average(self):
        rows = [{"satisfaction_score": 4.0}, {"satisfaction_score": 5.0}]
        mock_client, mock_query, mock_result = _make_supabase_mock(rows)

        with patch("db.analytics_repo.get_client", return_value=mock_client):
            from db.analytics_repo import get_customer_satisfaction_score
            score = get_customer_satisfaction_score()

        assert score == pytest.approx(4.5)

    def test_get_common_complaints_sorted(self):
        rows = [
            {"complaint_type": "damaged"},
            {"complaint_type": "missing"},
            {"complaint_type": "damaged"},
            {"complaint_type": "late"},
            {"complaint_type": "damaged"},
        ]
        mock_client, mock_query, mock_result = _make_supabase_mock(rows)

        with patch("db.analytics_repo.get_client", return_value=mock_client):
            from db.analytics_repo import get_common_complaints
            result = get_common_complaints(limit=10)

        assert result[0]["type"] == "damaged"
        assert result[0]["count"] == 3
        assert result[1]["type"] == "missing" or result[1]["type"] == "late"

    def test_get_common_complaints_respects_limit(self):
        rows = [{"complaint_type": c} for c in ["a", "b", "c", "d", "e"]]
        mock_client, mock_query, mock_result = _make_supabase_mock(rows)

        with patch("db.analytics_repo.get_client", return_value=mock_client):
            from db.analytics_repo import get_common_complaints
            result = get_common_complaints(limit=3)

        assert len(result) <= 3

    def test_get_daily_stats_aggregates(self):
        now = datetime.now(timezone.utc)
        today = now.date().isoformat()

        msg_rows = [
            {"user_id": "u1", "timestamp": now.isoformat(), "hallucination_flagged": False, "role": "user"},
            {"user_id": "u2", "timestamp": now.isoformat(), "hallucination_flagged": True,  "role": "bot"},
            {"user_id": "u1", "timestamp": now.isoformat(), "hallucination_flagged": False, "role": "bot"},
        ]
        complaint_rows = [{"created_at": now.isoformat()}]

        mock_client = MagicMock()
        msg_result = MagicMock()
        msg_result.data = msg_rows
        complaint_result = MagicMock()
        complaint_result.data = complaint_rows

        msg_query = MagicMock()
        msg_query.select.return_value = msg_query
        msg_query.gte.return_value = msg_query
        msg_query.execute.return_value = msg_result

        complaint_query = MagicMock()
        complaint_query.select.return_value = complaint_query
        complaint_query.gte.return_value = complaint_query
        complaint_query.execute.return_value = complaint_result

        # First call → messages table, second call → complaints table
        mock_client.table.side_effect = [msg_query, complaint_query]

        with patch("db.analytics_repo.get_client", return_value=mock_client):
            from db.analytics_repo import get_daily_stats
            result = get_daily_stats(days=7)

        assert len(result) >= 1
        day = result[0]
        assert day["date"] == today
        assert day["total_messages"] == 3
        assert day["unique_users"] == 2
        assert day["hallucinations_flagged"] == 1
        assert day["complaints"] == 1

    def test_get_daily_stats_empty(self):
        mock_client = MagicMock()
        empty = MagicMock()
        empty.data = []
        q = MagicMock()
        q.select.return_value = q
        q.gte.return_value = q
        q.execute.return_value = empty
        mock_client.table.return_value = q

        with patch("db.analytics_repo.get_client", return_value=mock_client):
            from db.analytics_repo import get_daily_stats
            result = get_daily_stats(days=7)

        assert result == []
